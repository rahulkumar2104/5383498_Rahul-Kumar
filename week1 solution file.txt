PLUS MINUS------------------------------------------------------
#include <bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'plusMinus' function below.
 *
 * The function accepts INTEGER_ARRAY arr as parameter.
 */

void plusMinus(vector<int> arr) {
    int n = arr.size();
    int pos = 0, neg = 0, zero = 0;
    for (int x : arr) {
        if (x > 0) ++pos;
        else if (x < 0) ++neg;
        else ++zero;
    }

    cout << fixed << setprecision(6);
    cout << static_cast<double>(pos) / n << "\n";
    cout << static_cast<double>(neg) / n << "\n";
    cout << static_cast<double>(zero) / n << "\n";
}

int main()
{
    string n_temp;
    getline(cin, n_temp);

    int n = stoi(ltrim(rtrim(n_temp)));

    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split(rtrim(arr_temp_temp));

    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        arr[i] = stoi(arr_temp[i]);
    }

    plusMinus(arr);

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) {
        tokens.push_back(token);
    }
    return tokens;
}

Mini-Max Sum---------------------------------------------------------------------
#include <bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'miniMaxSum' function below.
 *
 * The function accepts INTEGER_ARRAY arr as parameter.
 */

void miniMaxSum(vector<int> arr) {
    // We'll use long long for sums to avoid overflow.
    long long total = 0;
    int mn = INT_MAX;
    int mx = INT_MIN;

    for (int x : arr) {
        total += x;
        mn = min(mn, x);
        mx = max(mx, x);
    }

    long long minSum = total - mx;
    long long maxSum = total - mn;

    cout << minSum << " " << maxSum << "\n";
}

int main()
{
    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split(rtrim(arr_temp_temp));

    vector<int> arr(5);
    for (int i = 0; i < 5; i++) {
        arr[i] = stoi(arr_temp[i]);
    }

    miniMaxSum(arr);

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) {
        tokens.push_back(token);
    }
    return tokens;
}

Time Conversion--------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

/*
 * Complete the 'timeConversion' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts STRING s as parameter.
 */

string timeConversion(string s) {
    string hourStr = s.substr(0, 2);
    string minSec = s.substr(2, 6); // ":MM:SS"
    string period = s.substr(8, 2); // AM or PM

    int hour = stoi(hourStr);

    if (period == "AM") {
        if (hour == 12) hour = 0; // midnight case
    } else { // PM case
        if (hour != 12) hour += 12; // afternoon case
    }

    // Ensure two-digit hour
    ostringstream oss;
    oss << setw(2) << setfill('0') << hour << minSec;

    return oss.str();
}

int main() {
    string s;
    getline(cin, s);

    string result = timeConversion(s);

    cout << result << "\n";

    return 0;
}

Sparse Arrays--------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);

/*
 * Complete the 'matchingStrings' function below.
 *
 * The function accepts:
 *  - vector<string> strings
 *  - vector<string> queries
 *
 * It returns a vector<int> with counts for each query.
 */
vector<int> matchingStrings(const vector<string>& strings, const vector<string>& queries) {
    unordered_map<string, int> freq;
    freq.reserve(strings.size() * 2);

    for (const auto &s : strings) {
        ++freq[s];
    }

    vector<int> result;
    result.reserve(queries.size());
    for (const auto &q : queries) {
        auto it = freq.find(q);
        result.push_back(it == freq.end() ? 0 : it->second);
    }
    return result;
}

int main() {
    string line;

    // Read n
    if (!getline(cin, line)) return 0;
    int n = stoi(ltrim(rtrim(line)));

    // Read n strings
    vector<string> strings;
    strings.reserve(n);
    for (int i = 0; i < n; ++i) {
        getline(cin, line);
        strings.push_back(rtrim(line));
    }

    // Read q
    getline(cin, line);
    int q = stoi(ltrim(rtrim(line)));

    // Read q queries
    vector<string> queries;
    queries.reserve(q);
    for (int i = 0; i < q; ++i) {
        getline(cin, line);
        queries.push_back(rtrim(line));
    }

    vector<int> ans = matchingStrings(strings, queries);

    // Print each count on a new line
    for (int x : ans) {
        cout << x << "\n";
    }

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

Lonely Integer----------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'lonelyinteger' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts INTEGER_ARRAY a as parameter.
 */
int lonelyinteger(vector<int> a) {
    int x = 0;
    for (int v : a) x ^= v; // XOR of all elements leaves the unique one
    return x;
}

int main()
{
    string n_temp;
    getline(cin, n_temp);

    int n = stoi(ltrim(rtrim(n_temp)));

    string a_temp_temp;
    getline(cin, a_temp_temp);

    vector<string> a_temp = split(rtrim(a_temp_temp));

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        a[i] = stoi(a_temp[i]);
    }

    int result = lonelyinteger(a);

    cout << result << "\n";

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) {
        tokens.push_back(token);
    }
    return tokens;
}

Flipping bits----------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);

/*
 * Complete the 'flippingBits' function below.
 *
 * The function accepts an unsigned 32-bit integer n and returns
 * the unsigned 32-bit integer that is the bitwise complement of n.
 */
uint32_t flippingBits(uint32_t n) {
    return ~n; // flip all 32 bits
}

int main() {
    string q_temp;
    if (!getline(cin, q_temp)) return 0;
    int q = stoi(ltrim(rtrim(q_temp)));

    for (int i = 0; i < q; ++i) {
        string n_temp;
        getline(cin, n_temp);
        // parse robustly (input might fit in 32-bit, but read into larger type first)
        unsigned long long val = stoull(ltrim(rtrim(n_temp)));
        uint32_t n = static_cast<uint32_t>(val);
        uint32_t res = flippingBits(n);
        // Print as unsigned long long to avoid sign extension when printing on some systems
        cout << static_cast<unsigned long long>(res) << "\n";
    }

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

Diagonal Difference------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'diagonalDifference' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts 2D INTEGER_ARRAY arr as parameter.
 */
int diagonalDifference(vector<vector<int>> arr) {
    int n = arr.size();
    int primary = 0;
    int secondary = 0;

    for (int i = 0; i < n; i++) {
        primary += arr[i][i];
        secondary += arr[i][n - 1 - i];
    }

    return abs(primary - secondary);
}

int main()
{
    string n_temp;
    getline(cin, n_temp);

    int n = stoi(ltrim(rtrim(n_temp)));

    vector<vector<int>> arr(n);

    for (int i = 0; i < n; i++) {
        string arr_row_temp;
        getline(cin, arr_row_temp);

        vector<string> arr_row_items = split(rtrim(arr_row_temp));

        arr[i].resize(n);

        for (int j = 0; j < n; j++) {
            arr[i][j] = stoi(arr_row_items[j]);
        }
    }

    int result = diagonalDifference(arr);

    cout << result << "\n";

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) {
        tokens.push_back(token);
    }
    return tokens;
}

Counting Sort 1---------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'countingSort' function below.
 *
 * The function is expected to return an INTEGER_ARRAY.
 * The function accepts INTEGER_ARRAY arr as parameter.
 */
vector<int> countingSort(vector<int> arr) {
    vector<int> freq(100, 0); // frequency array with 100 elements

    for (int val : arr) {
        freq[val]++; // increment count at index = value
    }
    return freq;
}

int main()
{
    string n_temp;
    getline(cin, n_temp);

    int n = stoi(ltrim(rtrim(n_temp)));

    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split(rtrim(arr_temp_temp));

    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        arr[i] = stoi(arr_temp[i]);
    }

    vector<int> result = countingSort(arr);

    for (size_t i = 0; i < result.size(); i++) {
        cout << result[i] << (i + 1 < result.size() ? " " : "\n");
    }

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) {
        tokens.push_back(token);
    }
    return tokens;
}

Pangrams-------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

/*
 * Complete the 'pangrams' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts STRING s as parameter.
 */
string pangrams(string s) {
    vector<bool> seen(26, false);
    for (char c : s) {
        if (isalpha(static_cast<unsigned char>(c))) {
            seen[tolower(static_cast<unsigned char>(c)) - 'a'] = true;
        }
    }
    for (bool b : seen) if (!b) return "not pangram";
    return "pangram";
}

int main() {
    string s;
    getline(cin, s);
    cout << pangrams(s) << "\n";
    return 0;
}

Permuting Two Arrays-------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'twoArrays' function below.
 *
 * The function returns "YES" if there exists a permutation of A and B
 * such that for every i: A[i] + B[i] >= k. Otherwise returns "NO".
 */
string twoArrays(int k, vector<int> A, vector<int> B) {
    sort(A.begin(), A.end());               // ascending
    sort(B.begin(), B.end(), greater<int>()); // descending

    int n = A.size();
    for (int i = 0; i < n; ++i) {
        if (A[i] + B[i] < k) return "NO";
    }
    return "YES";
}

int main() {
    string q_temp;
    if (!getline(cin, q_temp)) return 0;
    int q = stoi(ltrim(rtrim(q_temp)));

    for (int qi = 0; qi < q; ++qi) {
        string nk_temp;
        getline(cin, nk_temp);
        while (rtrim(nk_temp).empty()) getline(cin, nk_temp); // skip blank lines if any

        vector<string> nk = split(rtrim(nk_temp));
        int n = stoi(nk[0]);
        int k = stoi(nk[1]);

        string A_temp;
        getline(cin, A_temp);
        while (rtrim(A_temp).empty()) getline(cin, A_temp);
        vector<string> A_items = split(rtrim(A_temp));
        vector<int> A(n);
        for (int i = 0; i < n; ++i) A[i] = stoi(A_items[i]);

        string B_temp;
        getline(cin, B_temp);
        while (rtrim(B_temp).empty()) getline(cin, B_temp);
        vector<string> B_items = split(rtrim(B_temp));
        vector<int> B(n);
        for (int i = 0; i < n; ++i) B[i] = stoi(B_items[i]);

        cout << twoArrays(k, A, B) << "\n";
    }

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) tokens.push_back(token);
    return tokens;
}

Subarray Division 1-----------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'birthday' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts the following parameters:
 *  1. INTEGER_ARRAY s
 *  2. INTEGER d
 *  3. INTEGER m
 */
int birthday(vector<int> s, int d, int m) {
    int n = s.size();
    if (m > n) return 0;

    int count = 0;
    int window_sum = 0;

    // initial window
    for (int i = 0; i < m; ++i) window_sum += s[i];
    if (window_sum == d) ++count;

    // slide window
    for (int i = m; i < n; ++i) {
        window_sum += s[i];
        window_sum -= s[i - m];
        if (window_sum == d) ++count;
    }

    return count;
}

int main() {
    string n_temp;
    getline(cin, n_temp);
    int n = stoi(ltrim(rtrim(n_temp)));

    string s_temp;
    getline(cin, s_temp);
    vector<string> s_tokens = split(rtrim(s_temp));
    vector<int> s(n);
    for (int i = 0; i < n; ++i) s[i] = stoi(s_tokens[i]);

    string dm_temp;
    getline(cin, dm_temp);
    vector<string> dm = split(rtrim(dm_temp));
    int d = stoi(dm[0]);
    int m = stoi(dm[1]);

    int result = birthday(s, d, m);
    cout << result << "\n";

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) tokens.push_back(token);
    return tokens;
}

XOR Strings 2------------------------------------------------------------


1. Find the Median--------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'findMedian' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts INTEGER_ARRAY arr as parameter.
 */
int findMedian(vector<int> arr) {
    sort(arr.begin(), arr.end());
    return arr[arr.size() / 2]; // size is odd by problem statement
}

int main()
{
    string n_temp;
    getline(cin, n_temp);

    int n = stoi(ltrim(rtrim(n_temp)));

    string arr_temp;
    getline(cin, arr_temp);

    vector<string> arr_items = split(rtrim(arr_temp));

    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        arr[i] = stoi(arr_items[i]);
    }

    int result = findMedian(arr);

    cout << result << "\n";

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) tokens.push_back(token);
    return tokens;
}


2. Flipping the Matrix----------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'flippingMatrix' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts 2D_INTEGER_ARRAY matrix as parameter.
 */
int flippingMatrix(vector<vector<int>> matrix) {
    int size = matrix.size();     // 2n
    int n = size / 2;
    long long sum = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            int a = matrix[i][j];
            int b = matrix[i][size - 1 - j];
            int c = matrix[size - 1 - i][j];
            int d = matrix[size - 1 - i][size - 1 - j];
            sum += max(max(a, b), max(c, d));
        }
    }
    return static_cast<int>(sum);
}

int main()
{
    string q_temp;
    getline(cin, q_temp);

    int q = stoi(ltrim(rtrim(q_temp)));

    for (int q_itr = 0; q_itr < q; q_itr++) {
        string n_temp;
        getline(cin, n_temp);

        int n = stoi(ltrim(rtrim(n_temp)));

        vector<vector<int>> matrix(2 * n);
        for (int i = 0; i < 2 * n; i++) {
            string matrix_row_temp;
            getline(cin, matrix_row_temp);

            vector<string> matrix_row_items = split(rtrim(matrix_row_temp));

            matrix[i].resize(2 * n);
            for (int j = 0; j < 2 * n; j++) {
                matrix[i][j] = stoi(matrix_row_items[j]);
            }
        }

        int result = flippingMatrix(matrix);

        cout << result << "\n";
    }

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(s.begin(), find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !isspace(ch);
    }));
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !isspace(ch);
    }).base(), s.end());
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string token;
    istringstream stream(str);
    while (stream >> token) tokens.push_back(token);
    return tokens;
}

XOR Strings 2--------------------------------------------------------------------------------
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

string strings_xor(string s, string t) {

    string res = "";
    for(int i = 0; i < s.size(); i++) {
        if(s[i] == t[i])
            res += '0';
        else
            res += '1';
    }

    return res;
}

int main() {
    string s, t;
    cin >> s >> t;
    cout << strings_xor(s, t) << endl;
    return 0;
}


