Sales by Match------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

int sockMerchant(int n, vector<int> ar) {
    unordered_map<int, int> colorCount;
    int pairs = 0;

    for (int color : ar) {
        colorCount[color]++;
    }

    for (auto& entry : colorCount) {
        pairs += entry.second / 2;
    }

    return pairs;
}

int main() {
    int n;
    cin >> n;

    vector<int> ar(n);
    for (int i = 0; i < n; i++) {
        cin >> ar[i];
    }

    int result = sockMerchant(n, ar);
    cout << result << endl;

    return 0;
}

Drawing Book----------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

int pageCount(int n, int p) {
    int fromFront = p / 2;
    int fromBack = (n / 2) - (p / 2);
    return min(fromFront, fromBack);
}

int main() {
    int n, p;
    cin >> n >> p;
    
    int result = pageCount(n, p);
    cout << result << endl;
    
    return 0;
}

Tower Breakers-------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

int towerBreakers(int n, int m) {
    if (m == 1 || n % 2 == 0)
        return 2;
    else
        return 1;
}

int main() {
    int t;
    cin >> t;
    
    while (t--) {
        int n, m;
        cin >> n >> m;
        cout << towerBreakers(n, m) << endl;
    }
    
    return 0;
}

Caesar Cipher----------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string caesarCipher(string s, int k) {
    k = k % 26;  // Normalize shift
    for (int i = 0; i < s.size(); ++i) {
        char ch = s[i];
        if (isalpha(ch)) {
            if (islower(ch)) {
                s[i] = 'a' + (ch - 'a' + k) % 26;
            } else if (isupper(ch)) {
                s[i] = 'A' + (ch - 'A' + k) % 26;
            }
        }
        // Non-letters remain unchanged
    }
    return s;
}

int main() {
    int n, k;
    string s;
    cin >> n;
    cin >> s;
    cin >> k;

    string result = caesarCipher(s, k);
    cout << result << endl;

    return 0;
}

Max Min-----------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

int maxMin(int k, vector<int> arr) {
    sort(arr.begin(), arr.end());
    int min_unfairness = INT_MAX;

    for (int i = 0; i <= arr.size() - k; ++i) {
        int unfairness = arr[i + k - 1] - arr[i];
        min_unfairness = min(min_unfairness, unfairness);
    }

    return min_unfairness;
}

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> arr(n);

    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    cout << maxMin(k, arr) << endl;
    return 0;
}

Dynamic Array----------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

vector<int> dynamicArray(int n, vector<vector<int>> queries) {
    vector<vector<int>> arr(n);  // 2D array of n empty arrays
    vector<int> result;
    int lastAnswer = 0;

    for (auto& q : queries) {
        int type = q[0];
        int x = q[1];
        int y = q[2];
        int idx = (x ^ lastAnswer) % n;

        if (type == 1) {
            arr[idx].push_back(y);
        } else if (type == 2) {
            int value = arr[idx][y % arr[idx].size()];
            lastAnswer = value;
            result.push_back(lastAnswer);
        }
    }

    return result;
}

int main() {
    int n, q;
    cin >> n >> q;

    vector<vector<int>> queries(q, vector<int>(3));
    for (int i = 0; i < q; i++) {
        cin >> queries[i][0] >> queries[i][1] >> queries[i][2];
    }

    vector<int> res = dynamicArray(n, queries);
    for (int val : res) {
        cout << val << endl;
    }

    return 0;
}

Grid Challenge-------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string gridChallenge(vector<string> grid) {
    int n = grid.size();

    // Step 1: Sort each row
    for (int i = 0; i < n; i++) {
        sort(grid[i].begin(), grid[i].end());
    }

    // Step 2: Check columns
    for (int col = 0; col < grid[0].size(); col++) {
        for (int row = 0; row < n - 1; row++) {
            if (grid[row][col] > grid[row + 1][col]) {
                return "NO";
            }
        }
    }

    return "YES";
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<string> grid(n);
        for (int i = 0; i < n; i++) {
            cin >> grid[i];
        }
        cout << gridChallenge(grid) << endl;
    }
    return 0;
}

Zig Zag Sequence--------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

void findZigZagSequence(vector < int > a, int n){
    sort(a.begin(), a.end());
    int mid = (n + 1)/2 - 1;
    swap(a[mid], a[n-1]);

    int st = mid + 1;
    int ed = n - 2;
    while(st <= ed){
        swap(a[st], a[ed]);
        st = st + 1;
        ed = ed - 1;
    }
    for(int i = 0; i < n; i++){
        if(i > 0) cout << " ";
        cout << a[i];
    }
    cout << endl;
}

int main() {
    int n, x;
    int test_cases;
    cin >> test_cases;

    for(int cs = 1; cs <= test_cases; cs++){
        cin >> n;
        vector < int > a;
        for(int i = 0; i < n; i++){
            cin >> x;
            a.push_back(x);
        }
        findZigZagSequence(a, n);
    }
}


Prime Dates-------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

int month[15];

void updateLeapYear(int year) {
    if(year % 400 == 0) {
        month[2] = 29;
    } else if(year % 100 == 0) {
        month[2] = 28;
    } else if(year % 4 == 0) {
        month[2] = 29;
    } else {
        month[2] = 28;
    }
}

void storeMonth() {
    month[1] = 31;
    month[2] = 28;
    month[3] = 31;
    month[4] = 30;
    month[5] = 31;
    month[6] = 30;
    month[7] = 31;
    month[8] = 31;
    month[9] = 30;
    month[10] = 31;
    month[11] = 30;
    month[12] = 31;
}

int findLuckyDates(int d1, int m1, int y1, int d2, int m2, int y2) {
    storeMonth();

    int result = 0;

    while(true) {
        int x = d1;
        x = x * 100 + m1;
        x = x * 10000 + y1;
        if(x % 4 == 0 || x % 7 == 0) {
            result = result + 1;
        }
        if(d1 == d2 && m1 == m2 && y1 == y2) {
            break;
        }
        updateLeapYear(y1);
        d1 = d1 + 1;
        if(d1 > month[m1]) {
            m1 = m1 + 1;
            d1 = 1;
            if(m1 > 12) {
                y1 =  y1 + 1;
                m1 = 1;
            }
        }
    }
    return result;
}

int main() {
    string str;
    int d1, m1, y1, d2, m2, y2;
    getline(cin, str);
    for(int i = 0; i < str.size(); i++) {
        if(str[i] == '-') {
            str[i] = ' ';
        }
    }
    stringstream ss;
    ss << str;
    ss >> d1 >> m1 >> y1 >> d2 >> m2 >> y2;

    int result = findLuckyDates(d1, m1, y1, d2, m2, y2);
    cout << result << endl;
}

Sherlock and Array---------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'balancedSums' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts INTEGER_ARRAY arr as parameter.
 */

string balancedSums(vector<int> arr) {
    int total = 0;
    for (int val : arr) {
        total += val;
    }

    int left_sum = 0;
    for (int i = 0; i < arr.size(); i++) {
        if (left_sum == total - left_sum - arr[i]) {
            return "YES";
        }
        left_sum += arr[i];
    }

    return "NO";
}

int main()
{
    string t_temp;
    getline(cin, t_temp);

    int t = stoi(ltrim(rtrim(t_temp)));

    for (int t_itr = 0; t_itr < t; t_itr++) {
        string n_temp;
        getline(cin, n_temp);

        int n = stoi(ltrim(rtrim(n_temp)));

        string arr_temp_temp;
        getline(cin, arr_temp_temp);

        vector<string> arr_temp = split(rtrim(arr_temp_temp));

        vector<int> arr(n);

        for (int i = 0; i < n; i++) {
            int arr_item = stoi(arr_temp[i]);
            arr[i] = arr_item;
        }

        string result = balancedSums(arr);
        cout << result << "\n";
    }

    return 0;
}

// Utility functions
string ltrim(const string &str) {
    string s(str);
    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string::size_type start = 0, end;

    while ((end = str.find(" ", start)) != string::npos) {
        tokens.push_back(str.substr(start, end - start));
        start = end + 1;
    }

    tokens.push_back(str.substr(start));
    return tokens;
}

Counter game--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);

string counterGame(long n) {
    int turns = 0;

    while (n != 1) {
        if ((n & (n - 1)) == 0) {
            n = n / 2;
        } else {
            long power = 1;
            while (power * 2 < n) {
                power *= 2;
            }
            n -= power;
        }
        turns++;
    }

    return (turns % 2 == 0) ? "Richard" : "Louise";
}

int main() {
    string t_temp;
    getline(cin, t_temp);
    int t = stoi(ltrim(rtrim(t_temp)));

    for (int t_itr = 0; t_itr < t; t_itr++) {
        string n_temp;
        getline(cin, n_temp);
        long n = stol(ltrim(rtrim(n_temp)));

        string result = counterGame(n);
        cout << result << "\n";
    }

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );
    return s;
}

Recursive Digit Sum---------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

int superDigit(string n, int k) {
    long long digitSum = 0;
    for (char c : n) {
        digitSum += c - '0';
    }

    digitSum *= k;

    if (digitSum < 10) {
        return digitSum;
    }

    return superDigit(to_string(digitSum), 1);
}

int main() {
    string first_multiple_input;
    getline(cin, first_multiple_input);

    vector<string> inputs = split(rtrim(first_multiple_input));

    string n = inputs[0];
    int k = stoi(inputs[1]);

    int result = superDigit(n, k);
    cout << result << "\n";

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );
    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string::size_type start = 0, end;

    while ((end = str.find(" ", start)) != string::npos) {
        tokens.push_back(str.substr(start, end - start));
        start = end + 1;
    }

    tokens.push_back(str.substr(start));
    return tokens;
}

Sum vs XOR------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

string ltrim(const string &);
string rtrim(const string &);

long sumXor(long n) {
    if (n == 0) return 1;

    int zeroBits = 0;
    while (n) {
        if ((n & 1) == 0) zeroBits++;
        n >>= 1;
    }

    return 1L << zeroBits;
}

int main() {
    string n_temp;
    getline(cin, n_temp);

    long n = stol(ltrim(rtrim(n_temp)));

    long result = sumXor(n);
    cout << result << "\n";

    return 0;
}

string ltrim(const string &str) {
    string s(str);
    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );
    return s;
}

string rtrim(const string &str) {
    string s(str);
    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );
    return s;
}



